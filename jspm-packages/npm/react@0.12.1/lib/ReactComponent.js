/* */
"format cjs";!function(e){"use strict";var t=require("./ReactElement"),n=require("./ReactOwner"),r=require("./ReactUpdates"),o=require("./Object.assign"),a=require("./invariant"),i=require("./keyMirror"),s=i({MOUNTED:null,UNMOUNTED:null}),u=!1,c=null,l=null,p={injection:{injectEnvironment:function(t){"production"!==e.env.NODE_ENV?a(!u,"ReactComponent: injectEnvironment() can only be called once."):a(!u),l=t.mountImageIntoNode,c=t.unmountIDFromEnvironment,p.BackendIDOperations=t.BackendIDOperations,u=!0}},LifeCycle:s,BackendIDOperations:null,Mixin:{isMounted:function(){return this._lifeCycleState===s.MOUNTED},setProps:function(e,t){var n=this._pendingElement||this._currentElement;this.replaceProps(o({},n.props,e),t)},replaceProps:function(n,o){"production"!==e.env.NODE_ENV?a(this.isMounted(),"replaceProps(...): Can only update a mounted component."):a(this.isMounted()),"production"!==e.env.NODE_ENV?a(0===this._mountDepth,"replaceProps(...): You called `setProps` or `replaceProps` on a component with a parent. This is an anti-pattern since props will get reactively updated when rendered. Instead, change the owner's `render` method to pass the correct value as props to the component where it is created."):a(0===this._mountDepth),this._pendingElement=t.cloneAndReplaceProps(this._pendingElement||this._currentElement,n),r.enqueueUpdate(this,o)},_setPropsInternal:function(e,n){var a=this._pendingElement||this._currentElement;this._pendingElement=t.cloneAndReplaceProps(a,o({},a.props,e)),r.enqueueUpdate(this,n)},construct:function(e){this.props=e.props,this._owner=e._owner,this._lifeCycleState=s.UNMOUNTED,this._pendingCallbacks=null,this._currentElement=e,this._pendingElement=null},mountComponent:function(t,r,o){"production"!==e.env.NODE_ENV?a(!this.isMounted(),"mountComponent(%s, ...): Can only mount an unmounted component. Make sure to avoid storing components between renders or reusing a single component instance in multiple places.",t):a(!this.isMounted());var i=this._currentElement.ref;if(null!=i){var u=this._currentElement._owner;n.addComponentAsRefTo(this,i,u)}this._rootNodeID=t,this._lifeCycleState=s.MOUNTED,this._mountDepth=o},unmountComponent:function(){"production"!==e.env.NODE_ENV?a(this.isMounted(),"unmountComponent(): Can only unmount a mounted component."):a(this.isMounted());var t=this._currentElement.ref;null!=t&&n.removeComponentAsRefFrom(this,t,this._owner),c(this._rootNodeID),this._rootNodeID=null,this._lifeCycleState=s.UNMOUNTED},receiveComponent:function(t,n){"production"!==e.env.NODE_ENV?a(this.isMounted(),"receiveComponent(...): Can only update a mounted component."):a(this.isMounted()),this._pendingElement=t,this.performUpdateIfNecessary(n)},performUpdateIfNecessary:function(e){if(null!=this._pendingElement){var t=this._currentElement,n=this._pendingElement;this._currentElement=n,this.props=n.props,this._owner=n._owner,this._pendingElement=null,this.updateComponent(e,t)}},updateComponent:function(e,t){var r=this._currentElement;(r._owner!==t._owner||r.ref!==t.ref)&&(null!=t.ref&&n.removeComponentAsRefFrom(this,t.ref,t._owner),null!=r.ref&&n.addComponentAsRefTo(this,r.ref,r._owner))},mountComponentIntoNode:function(e,t,n){var o=r.ReactReconcileTransaction.getPooled();o.perform(this._mountComponentIntoNode,this,e,t,o,n),r.ReactReconcileTransaction.release(o)},_mountComponentIntoNode:function(e,t,n,r){var o=this.mountComponent(e,n,0);l(o,t,r)},isOwnedBy:function(e){return this._owner===e},getSiblingByRef:function(e){var t=this._owner;return t&&t.refs?t.refs[e]:null}}};module.exports=p}(require("github:jspm/nodelibs@0.0.3/process"));
//# sourceMappingURL=ReactComponent.js.map